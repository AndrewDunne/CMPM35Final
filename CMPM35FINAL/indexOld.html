<!DOCTYPE html>
<html>
	<head>
		<title>Diorama</title>
	</head>
	<body>
    
  

  <script type="module">
    import * as THREE from './js/build/three.module.js'
	import { OBJLoader } from './js/examples/jsm/controls/three-OBJLoader.js'
	import { MTLLoader } from './js/examples/jsm/controls/MTLLoader.js'
	import { OrbitControls } from './js/examples/jsm/controls/OrbitControls.js'
	//import { LightProbeHelper } from './js/examples/jsm/lighting/LightProbeHelper.js'
	
 
    const scene = new THREE.Scene();
	scene.background = new THREE.Color(0x888888);
	scene.fog = new THREE.Fog(0x888888, 0, 5);
	
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 3;

    const renderer = new THREE.WebGLRenderer();
	renderer.shadowMapEnabled = true;

    //make the canvas take up the entire browser window
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

	// Orbit controls
    const controls = new OrbitControls(camera, renderer.domElement);
	controls.maxPolarAngle = Math.PI/2;
	
	// Secret lab 
	const geometry = new THREE.BoxGeometry(1,1,1);
	const material1 = new THREE.MeshPhongMaterial({color: 0x666666});
	const lab = new THREE.Mesh(geometry, material1);
	lab.position.set(0,0,0); 
	lab.receiveShadow = true;
	lab.castShadow = true;
	scene.add(lab);
	
	// Window 1
	const windowGeometry = new THREE.BoxGeometry(.2,.2,.05);
	const windowMaterial = new THREE.MeshPhongMaterial({emissive: 0xffff00, opacity: 0.1, transparent: true,});
	const labWindow = new THREE.Mesh(windowGeometry, windowMaterial);
	labWindow.position.set(0.2,.2,.5); 
	scene.add(labWindow);
	
	// Window 2
	const labWindow2 = new THREE.Mesh(windowGeometry, windowMaterial);
	labWindow2.position.set(-0.2,.2,.5); 
	scene.add(labWindow2);
	
	//diorama base - lower piece
	const geometry2 = new THREE.SphereGeometry(3, 32, 32, 0, 2*Math.PI, 1.75, Math.PI/2);
    const material2 = new THREE.MeshPhongMaterial({color: 0x553322});
    const dioBase = new THREE.Mesh(geometry2, material2);
    dioBase.position.x = 0; 
    dioBase.position.y = 0;
	dioBase.receiveShadow = true;
	dioBase.castShadow = true;
    scene.add(dioBase);

	//diorama base - upper piece
    const geometry3 = new THREE.SphereGeometry(8.5, 32, 32, 0, 2*Math.PI, 0, Math.PI/9) 
    const material3 = new THREE.MeshPhongMaterial({color: 0xddddff});
    const dioGround = new THREE.Mesh(geometry3, material3);
    dioGround.position.x = 0; 
    dioGround.position.y = -8.58; //the larger the shape, the higher it goes, it helps to have the size and negative ypos be the same
	dioGround.receiveShadow = true;
	dioGround.castShadow = true;
    scene.add(dioGround);







	/*const light1 = new THREE.PointLight(0xffffff);
	light1.position.set(0,0,2);
	scene.add(light1);
	
	const hemiLight = new THREE.HemisphereLight(0xffffff, 0xaaaaaa);
	scene.add( hemiLight );*/
	
	// Sun light, with cast shadows
	let sun1 = new THREE.DirectionalLight(0xdfebff, 1.75);
    sun1.position.set(-5, 5, 5);
    sun1.position.multiplyScalar(1.3);

    sun1.castShadow = true;

    sun1.shadowMapWidth = 1024;
    sun1.shadowMapHeight = 1024;

    var d = 2; // Size of camera lens

    sun1.shadow.camera.left = -d;
    sun1.shadow.camera.right = d;
    sun1.shadow.camera.top = d;
    sun1.shadow.camera.bottom = -d;

    sun1.shadow.camera.far = 20;
    sun1.shadow.darkness = 1;

    scene.add(sun1);
	
	let shadowCam = new THREE.CameraHelper( sun1.shadow.camera );
	scene.add(shadowCam);
	// End sun light
	
	
	
	/*let probe = new THREE.LightProbe();
	probe.position.set(3,0,-15);
	scene.add(probe);
	const helper = new LightProbeHelper( probe, 1 );
	scene.add( helper );*/
	
	


const mtloader = new MTLLoader();

mtloader.load('./CMPM35Water.mtl', function(materials){

	materials.preload();
	
	const loader = new OBJLoader();
	loader.setMaterials(materials);
	loader.load(
		// resource URL
		'./CMPM35Water.obj',
		// called when resource is loaded
		function ( object ) {
			object.traverse(function(child){child.castShadow = true;});
			object.traverse(function(child){child.receiveShadow = true;});
			object.position.set(0,-3.3,0);
			object.rotation.set(0,3.1415/2,0);
			object.scale.set(3,3,3);
			scene.add( object );
			

		},
		// called when loading is in progresses
		function ( xhr ) {

			console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
	
		},
		// called when loading has errors
		function ( error ) {

			console.log( 'An error happened' );

		}
	);

});

    const animate = function () {
      requestAnimationFrame(animate);
	  
      renderer.render(scene, camera);
    };

    animate();

    function rotateObject(o, dx, dy) {
      o.rotation.x += dx;
      o.rotation.y += dy;
    }

  </script>
  </body>
  
  </html>