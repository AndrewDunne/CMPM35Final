<!DOCTYPE html>
<html>
	<head>
		<title>shapes</title>
	</head>
	<body>
    
  

  <script type="module">
    import * as THREE from './js/build/three.module.js'
	import { OBJLoader } from './js/examples/jsm/controls/three-OBJLoader.js'
	import { MTLLoader } from './js/examples/jsm/controls/MTLLoader.js'
	import { OrbitControls } from './js/examples/jsm/controls/OrbitControls.js'
	//import { LightProbeHelper } from './js/examples/jsm/lighting/LightProbeHelper.js'
	
 
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    //we are going to place our 3D meshes at the center of the world's coordinate system, 
    //  so we move the camera so that it can see them 
    camera.position.z = 5;
	camera.position.y = 5;

    const renderer = new THREE.WebGLRenderer();
	renderer.shadowMapEnabled = true;
	
	let moveForward = false, moveRight = false, moveBackward = false, moveLeft = false, moveUp = false, moveDown = false;
	let moveSpeed = 1;
	let prevTime = performance.now();
	const velocity = new THREE.Vector3();
	const direction = new THREE.Vector3();

    //make the canvas take up the entire browser window
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
	
	const geometry = new THREE.BoxGeometry(1,1,1);
	const material1 = new THREE.MeshPhongMaterial();
	const cube = new THREE.Mesh(geometry, material1);
	cube.receiveShadow = true;
	scene.add(cube);
	
	//diorama base - lower piece
	const geometry2 = new THREE.SphereGeometry(3, 32, 32, 0, 2*Math.PI, 1.75, Math.PI/2);
    const material2 = new THREE.MeshPhongMaterial();
    const sphere = new THREE.Mesh(geometry2, material2);
    sphere.position.x = 0; 
    sphere.position.y = 0;
    scene.add(sphere);

	//diorama base - upper piece
    const geometry3 = new THREE.SphereGeometry(8.5, 32, 32, 0, 2*Math.PI, 0, Math.PI/9) 
    const material3 = new THREE.MeshPhongMaterial();
    const sphere2 = new THREE.Mesh(geometry3, material3);
    sphere2.position.x = 0; 
    sphere2.position.y = -8.5; //the larger the shape, the higher it goes, it helps to have the size and negative ypos be the same
    scene.add(sphere2);







	const light1 = new THREE.PointLight(0xffffff);
	light1.position.set(0,0,2);
	scene.add(light1);
	
	const hemiLight = new THREE.HemisphereLight(0xffffff, 0xaaaaaa);
	scene.add( hemiLight );
	
	let sun1 = new THREE.DirectionalLight(0xdfebff, 1.75);
    sun1.position.set(-5, 5, 5);
    sun1.position.multiplyScalar(1.3);

    sun1.castShadow = true;

    sun1.shadowMapWidth = 1024;
    sun1.shadowMapHeight = 1024;

    var d = 2; // Size of camera lens

    sun1.shadow.camera.left = -d;
    sun1.shadow.camera.right = d;
    sun1.shadow.camera.top = d;
    sun1.shadow.camera.bottom = -d;

    sun1.shadow.camera.far = 20;
    sun1.shadow.darkness = 1;

    scene.add(sun1);
	
	let shadowCam = new THREE.CameraHelper( sun1.shadow.camera );
	scene.add(shadowCam);
	
	// HDRI
	/*
	const genCubeUrls = function ( prefix, postfix ) {

					return [
						prefix + 'px' + postfix, prefix + 'nx' + postfix,
						prefix + 'py' + postfix, prefix + 'ny' + postfix,
						prefix + 'pz' + postfix, prefix + 'nz' + postfix
					];

				};

				const urls = genCubeUrls( './textures/montana-northern-plains', '.jpg' );

				new THREE.CubeTextureLoader().load( urls, function ( cubeTexture ) {

					cubeTexture.encoding = THREE.sRGBEncoding;

					scene.background = cubeTexture;

					lightProbe.copy( LightProbeGenerator.fromCubeTexture( cubeTexture ) );

					const geometry = new THREE.SphereBufferGeometry( 5, 64, 32 );
					//const geometry = new TorusKnotBufferGeometry( 4, 1.5, 256, 32, 2, 3 );

					const material = new THREE.MeshStandardMaterial( {
						color: 0xffffff,
						metalness: 0,
						roughness: 0,
						envMap: cubeTexture,
						envMapIntensity: API.envMapIntensity,
					} );

					// mesh
					mesh = new THREE.Mesh( geometry, material );
					scene.add( mesh );

					render();

				} );
	
	*/
	
	
	
	/*let probe = new THREE.LightProbe();
	probe.position.set(3,0,-15);
	scene.add(probe);
	const helper = new LightProbeHelper( probe, 1 );
	scene.add( helper );*/
	
	


const mtloader = new MTLLoader();

mtloader.load('./CMPM35Water.mtl', function(materials){

	materials.preload();
	
	const loader = new OBJLoader();
	loader.setMaterials(materials);
	loader.load(
		// resource URL
		'./CMPM35Water.obj',
		// called when resource is loaded
		function ( object ) {
			object.traverse(function(child){child.castShadow = true;});
			object.traverse(function(child){child.receiveShadow = true;});
			object.position.set(0,-3.3,0);
			object.scale.set(3,3,3);
			scene.add( object );
			

		},
		// called when loading is in progresses
		function ( xhr ) {

			console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
	
		},
		// called when loading has errors
		function ( error ) {

			console.log( 'An error happened' );

		}
	);

});

    const animate = function () {
      requestAnimationFrame(animate);
	  
      renderer.render(scene, camera);
    };

    animate();

    function rotateObject(o, dx, dy) {
      o.rotation.x += dx;
      o.rotation.y += dy;
    }

  </script>
  </body>
  
  </html>